// Copyright (c) 2019 Winter Chen. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
//本代码是从LevelDB中移植过来的bloomfilter

// Copyright (c) 2011 The LevelDB Authors. All rights reserved.
// Use of this source code is governed by a BSD-style license that can be
// found in the LICENSE file. See the AUTHORS file for names of contributors.
#include "bloomfilter.h"
#include "hash.h"
using namespace leveldb;


static uint32_t BloomHash(const string& key) {
  return Hash(key.c_str(), key.size(), 0xbc9f1d34);
}

void BloomFilter::CreateFilter(int n){
    // Compute bloom filter size (in both bits and bytes)
    bits = n * bits_per_key_;

    // For small n, we can see a very high false positive rate.  Fix it
    // by enforcing a minimum bloom filter length.
    if (bits < 64) bits = 64;

    size_t bytes = (bits + 7) / 8;
    bits = bytes * 8;

    const size_t init_size = 0;
    bloom_filter.resize(init_size + bytes, 0);
    bloom_filter.push_back(static_cast<char>(k_));  // Remember # of probes in filter
}

bool BloomFilter::KeyMayMatch(const string& key){
    const size_t len = bloom_filter.size();
    if (len < 2) return false;

    const char* array = bloom_filter.data();
    const size_t bits = (len - 1) * 8;

    // Use the encoded k so that we can read filters generated by
    // bloom filters created using different parameters.
    const size_t k = array[len-1];
    if (k > 30) {
      // Reserved for potentially new encodings for short bloom filters.
      // Consider it a match.
      return true;
    }
    uint32_t h = BloomHash(key);
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k; j++) {
      const uint32_t bitpos = h % bits;
      if ((array[bitpos/8] & (1 << (bitpos % 8))) == 0) return false;
      h += delta;
    }
    return true;
}

void BloomFilter::Add(const string &key){
    // Use double-hashing to generate a sequence of hash values.
    // See analysis in [Kirsch,Mitzenmacher 2006].
    uint32_t h = BloomHash(key);
    char* array = &(bloom_filter)[0];
    const uint32_t delta = (h >> 17) | (h << 15);  // Rotate right 17 bits
    for (size_t j = 0; j < k_; j++) {
        const uint32_t bitpos = h % bits;
        array[bitpos/8] |= (1 << (bitpos % 8));
        h += delta;
    }
}

string BloomFilter::GetInfo(){
    char str[100] = {0};
    sprintf(str, "k:%zu,bits:%zu,bits_per_key:%zu,string_size:%zu", k_, bits, bits_per_key_,bloom_filter.size());
    return string(str);
}